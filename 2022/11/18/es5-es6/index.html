<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ES5～ES6语法 | 高产</title>
    <meta name="generator" content="VuePress 1.9.8">
    
    <meta name="description" content="
let a;
const b;
与 var 声明变量的区别

不属于顶层window

不允许重复声明

不存在变量提升

暂时性死区

- 暂时性死区：不能在变量声明之前使用变量

块级作用域

解构赋值

数组解构赋值
let [a,b,c,d,e = 6] = [1,2,3,[4,5]];
对象解构赋值
l ...">
    
    <link rel="preload" href="/blog/assets/css/0.styles.a97dc209.css" as="style"><link rel="preload" href="/blog/assets/js/app.6d5b5a7a.js" as="script"><link rel="preload" href="/blog/assets/js/6.fe35a745.js" as="script"><link rel="preload" href="/blog/assets/js/3.1b59b54d.js" as="script"><link rel="preload" href="/blog/assets/js/16.dad7f127.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.2b827ecb.js"><link rel="prefetch" href="/blog/assets/js/11.f3973602.js"><link rel="prefetch" href="/blog/assets/js/12.c47f2e56.js"><link rel="prefetch" href="/blog/assets/js/13.10a43ffa.js"><link rel="prefetch" href="/blog/assets/js/14.380c173f.js"><link rel="prefetch" href="/blog/assets/js/15.5f02a601.js"><link rel="prefetch" href="/blog/assets/js/17.f91ca90f.js"><link rel="prefetch" href="/blog/assets/js/18.bfff0def.js"><link rel="prefetch" href="/blog/assets/js/19.bfcad07f.js"><link rel="prefetch" href="/blog/assets/js/20.602df238.js"><link rel="prefetch" href="/blog/assets/js/21.1c165100.js"><link rel="prefetch" href="/blog/assets/js/22.04b1546a.js"><link rel="prefetch" href="/blog/assets/js/23.2ed1fe3c.js"><link rel="prefetch" href="/blog/assets/js/24.9e9399bc.js"><link rel="prefetch" href="/blog/assets/js/25.12c5acb7.js"><link rel="prefetch" href="/blog/assets/js/4.42a7e1f0.js"><link rel="prefetch" href="/blog/assets/js/5.19af5458.js"><link rel="prefetch" href="/blog/assets/js/7.276877ea.js"><link rel="prefetch" href="/blog/assets/js/8.c7302ada.js"><link rel="prefetch" href="/blog/assets/js/9.6f699372.js"><link rel="prefetch" href="/blog/assets/js/vuejs-paginate.2ff59520.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.a97dc209.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/blog/" class="nav-link home-link">高产 </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/blog/" class="nav-link">ECMAScript</a></li><li class="nav-item"><a href="/blog/sourceCode/" class="nav-link">源码解析</a></li><li class="nav-item"><a href="/blog/interview/" class="nav-link">面试</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/blog/" class="nav-link mobile-home-link">高产 </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/blog/" class="nav-link">ECMAScript</a></li><li class="mobile-nav-item"><a href="/blog/sourceCode/" class="nav-link">源码解析</a></li><li class="mobile-nav-item"><a href="/blog/interview/" class="nav-link">面试</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        ES5～ES6语法
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">December</span> <span itemprop="address">   in chengdu</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2022-11-18T00:00:00.000Z">
      Fri Nov 18 2022
    </time></div> <!----></div></header> <div itemprop="articleBody" class="content__default"><h3 id="新的声明方式"><a href="#新的声明方式" class="header-anchor">#</a> 新的声明方式</h3> <div class="language- extra-class"><pre class="language-text"><code>let a;
const b;
</code></pre></div><p>与 var 声明变量的区别</p> <ul><li><p>不属于顶层window</p></li> <li><p>不允许重复声明</p></li> <li><p>不存在变量提升</p></li> <li><p>暂时性死区</p></li> <li><ul><li><em>暂时性死区：不能在变量声明之前使用变量</em></li></ul></li> <li><p>块级作用域</p></li></ul> <h3 id="解构赋值"><a href="#解构赋值" class="header-anchor">#</a> 解构赋值</h3> <ul><li>数组解构赋值</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let [a,b,c,d,e = 6] = [1,2,3,[4,5]];
</code></pre></div><ul><li>对象解构赋值</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let obj = {
    name: 'admin',
    uid: '001',
    code: [111,222,333],
};

let {name,uid,code:userCode} = obj;
</code></pre></div><h3 id="es5中数组的遍历方式"><a href="#es5中数组的遍历方式" class="header-anchor">#</a> ES5中数组的遍历方式</h3> <ul><li>for循环</li> <li>forEcah(): 没有返回，每个元素调用func</li></ul> <div class="language- extra-class"><pre class="language-text"><code>/**
 * @param {*} item 正在遍历的元素
 * @param {*} index 正在遍历的元素下标
 * @param {*} array 正在遍历的数组本身
 * **/ 

arr.forEach((item,index,array) =&gt; {
    console.log('item,index,array: ', item,index,array);
})
</code></pre></div><ul><li>map(): 返回新数组，每个新元素为调用func的结果</li> <li>filter(): 返回符合func条件的元素数组</li> <li>some(): 返回Boolean，判断某个元素是否符合func条件</li> <li>every(): 返回Boolean，判断每个元素是否符合func条件</li> <li>reduce(): 接受一个func作为累加器</li></ul> <div class="language- extra-class"><pre class="language-text"><code>/**
 * @param {*} func方法
 *** @param {*} pre 上一次函数调用的值，第一次对应的是初始值
 *** @param {*} cur 正在处理的值
 *** @param {*} index 当前处理的值的下标
 *** @param {*} array 源数据
 * @param {*} 0 初始值 可以是0 可以是{} 也可以是[]
 * **/ 
 let sum = arr.reduce((prev, cur, index, array) =&gt; {
    return prev + cur
 }, 0)
 console.log(sum);
</code></pre></div><ul><li>for in 可以遍历数组的key，也能遍历对象的key，甚至能遍历到原型上。</li></ul> <h3 id="es6中数组的遍历方式"><a href="#es6中数组的遍历方式" class="header-anchor">#</a> ES6中数组的遍历方式</h3> <ul><li>find(): 返回第一个通过判断条件的元素</li> <li>findIndex(): 返回第一个通过判断条件的元素的key</li> <li>for of循环: 遍历数组的每个元素</li> <li><ul><li>values(): 遍历数组的每个元素</li></ul></li> <li><ul><li>keys():遍历数组的每个元素的key</li></ul></li> <li><ul><li>entries()：遍历数组的每个元素和key</li></ul></li></ul> <h3 id="es6中数组方法"><a href="#es6中数组方法" class="header-anchor">#</a> ES6中数组方法</h3> <ul><li>Array.from(): 把类数组和伪数组转化为真数组</li> <li>Array.of(): 参数为单个数字时：声明长度为n的数组；长度为多个时：声明这些值为新的数组。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let arr = Array.of(3);
console.log(arr.length); //3

let arr1 = Array.of(1, true, 'imooc', [1, 2, 3], {name: 'xiecheng'});
console.log(arr1); // [1, true, 'imooc', [1, 2, 3], {ame: 'xiecheng'}]
</code></pre></div><ul><li>copyWithin(): 用数组的某些元素替换数组中的元素。</li> <li>fill(): 填充数组</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let arr = Array.of(3).fill(null);
console.log(arr); //[null,nbull,null]
let arr1 = [1,2,3,4,5];
arr.fill('test'.1,3);
console.log('arr: ', arr);// [1,'test','test',4,5];

</code></pre></div><h3 id="扩展运算符与rest参数"><a href="#扩展运算符与rest参数" class="header-anchor">#</a> 扩展运算符与rest参数</h3> <ul><li>扩展运算符:  把数组或者类数组展开变成用‘,’隔开的值</li> <li>rest参数: 把逗号隔开的值，变成数组</li></ul> <h3 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数</h3> <ul><li>自身没有this，而是继承父级的this</li> <li>不可以当作构造函数</li> <li>不可以使用arguments对象（可以使用‘...’rest运算符）</li></ul> <h3 id="对象方法"><a href="#对象方法" class="header-anchor">#</a> 对象方法</h3> <ul><li>属性简介表达</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let name = 'admin';
let age = 18;
let obj = {
    name,
    age,
}
</code></pre></div><ul><li>属性名表达试</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let s = 'school'
let obj = {
    [s]: '学校',
    saySchool(){
        console.log('好学校');
    }
</code></pre></div><ul><li>Object.is(): 判断两个值是否严格相等</li></ul> <div class="language- extra-class"><pre class="language-text"><code>console.log('Object.is(2,'2'): ', Object.is(2,'2')); //  false
</code></pre></div><ul><li>Object.assign(): 合并对象,也可以返回一个合并对象</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let x = {
    name: 'admin',
    age: 18
}
let y = {};
Object.assign(y,x);// {name: 'admin',age: 18}
let z = Object.assign(y,x);
console.log('z: ', z); // {name: 'admin',age: 18}
</code></pre></div><ul><li>in: 判断数组或者对象是否有某个key</li> <li>对象遍历</li></ul> <div class="language- extra-class"><pre class="language-text"><code>for(let key in obj){
    console.log(key, obj[key])
}

Object.keys(obj).forEach(key =&gt; {
    console.log(key, obj[key])
})

Object.getOwnPropertyNames(obj).forEach(key =&gt;{
     console.log(key, obj[key])
})

Reflect.ownKeys(obj).forEach(key =&gt; {
    console.log(key, obj[key])
})
</code></pre></div><h3 id="类与继承"><a href="#类与继承" class="header-anchor">#</a> 类与继承</h3> <ul><li>ES5中的类与继承</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// ES5的类声明

//  父类
function People (name,age) {
    //  实例属性
    this.name = name;
    this.age = age;
}

// 静态属性
People.count = 0;

// 静态方法
People.getCount = function () {
    return this.age;
}

// 实例方法
People.prototype.getCount = function () {
    return this.age;
}
var people = new People('小','18');

console.log('People.count: ', People.count);

// 子类

//  组合继承： 构造函数继承 + 原型继承
function Child(name, age, height) {
    People.call(this, name, age) // 继承属性： 构造函数继承
    this.height = height
}

// 方法继承： 原型继承
Child.prototype = new People();
//  修改原型指针
Child.prototype.constuctor = Child;

let child = new Child('wangcai', 18, 'white')
</code></pre></div><ul><li>ES6中的类与继承
<ul><li>class 语法糖：类声明</li> <li>extends 语法糖：继承</li> <li>spuer 语法糖：子类继承父类的属性</li> <li>static 语法糖：静态属性（方法）的声明</li> <li>constructor 语法糖：类里面的构造函数</li> <li>get/set 对属性进行拦截</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// ES6的类声明

class People {
    constructor (name, age) {
        // 实例属性
        this.name = name
        this.age = age
        this._sex = 0
    }

    //  实例化方法
    showName () {
        return this.name
    }

    get sex () {
        if (this._sex === 1) {
            return 'male'
        } else if (this._sex === 0) {
            return 'female'
        } else {
            return 'error'
        }
    }
    set sex (val) { 
        // 1:male 0:female
        if (val === 0 || val === 1) {
            this._sex = val
        }

    }

    // 静态属性: ES6之后才支持

    static count = 0

    //  静态方法
    static getCount() {}
}

// 静态属性: ES6写法
// People.count = 0

let people = new People('张三',18);

// extends 关键字继承
class Child extends People {
    constructor(name, age,heigth) {
        // 属性继承
        super(name, age)
        this.heigth = heigth
    }
    showHeigth () {
        return this.heigth
    }
}

let child = new Child('李四', 18, 185);
</code></pre></div><h4 id="静态属性-方法-和实力属性-方法-的区别"><a href="#静态属性-方法-和实力属性-方法-的区别" class="header-anchor">#</a> 静态属性（方法）和实力属性（方法）的区别：</h4> <ol><li>静态属性（方法）是声明在类里面的</li> <li>实例属性（方法）是声明在构造函数里面的</li> <li>静态属性（方法）不需要类实例化且和实例属性（方法）不相通</li> <li>静态属性（方法）的this是指向类本身</li> <li>实例属性（方法）的this是指向实例化的对象上</li></ol> <h3 id="set-数据结构"><a href="#set-数据结构" class="header-anchor">#</a> Set 数据结构</h3> <ul><li>Set 是唯一值的集合。</li> <li>每个值在 Set 中只能出现一次。</li> <li><ul><li><em>Set的值只能唯一，所以能别去重（基本类型），引用类型因为存储机制，Set的特性不能被很好的运用。</em></li></ul></li> <li>一个 Set 可以容纳任何数据类型的任何值。</li></ul> <h3 id="weakset-数据结构"><a href="#weakset-数据结构" class="header-anchor">#</a> WeakSet 数据结构</h3> <ul><li>WeakSet只能添加对象</li> <li>WeakSet 不能遍历，是因为成员都是弱引用</li> <li>弱引用便于垃圾回收，防止内存泄漏</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let ws = new WeakSet()
const obj1 = {
    name: 'imooc'
}
const obj2 = {
    age: 5
}
ws.add(obj1)
ws.add(obj2)
// ws.delete(obj1)
</code></pre></div><h3 id="map-数据结构"><a href="#map-数据结构" class="header-anchor">#</a> Map 数据结构</h3> <ul><li>Map的性能高于Object。</li> <li>任何值都可以为key</li></ul> <h3 id="weakmap-数据结构"><a href="#weakmap-数据结构" class="header-anchor">#</a> WeakMap 数据结构</h3> <ul><li>WeakMap只接受对象作为键名（null除外）</li> <li>WeakMap的键名所引用的对象都是弱引用。</li> <li>弱引用便于垃圾回收，防止内存泄漏</li></ul> <h3 id="数值扩展"><a href="#数值扩展" class="header-anchor">#</a> 数值扩展</h3> <ul><li>Number.isFinite(n)： 判断n是否是有限数值</li> <li>Number.isNaN(n)： 判断n是否是NaN</li> <li>Number.parseInt(5.5)： 取整数</li> <li>Number.parseFloat(5.5)： 取浮点数</li> <li>Number.isInteger(5)： 判断是否是整数</li> <li>Math.trunc(5)： 去除小数，返回整数（存在隐式转换）</li> <li>Math.sign(1)： 判断参数是正书or负数or0（存在隐式转换）</li></ul> <h3 id="reflect对象"><a href="#reflect对象" class="header-anchor">#</a> Reflect对象</h3> <h4 id="reflect对象-约等于-object对象"><a href="#reflect对象-约等于-object对象" class="header-anchor">#</a> Reflect对象 约等于 Object对象</h4> <ul><li>Reflect.apply()</li> <li>Reflect.defineProperty()</li> <li>Reflect.has()</li> <li>Reflect.ownKeys()</li> <li>...</li></ul> <h3 id="iterator-迭代器"><a href="#iterator-迭代器" class="header-anchor">#</a> Iterator 迭代器</h3> <ul><li>让不支持遍历的结构可以遍历</li></ul> <h3 id="module-模块化"><a href="#module-模块化" class="header-anchor">#</a> Module 模块化</h3> <ul><li>export： 命名倒出一个文件能倒出多次，必须使用{} 包含</li> <li>import：倒入文件</li> <li>as： 倒出设置别名</li> <li>export default： 默认带出，一个倒出文件。只能有一个磨人倒出</li></ul></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h3 active"><a href="#新的声明方式" title="新的声明方式">新的声明方式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#解构赋值" title="解构赋值">解构赋值</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#es5中数组的遍历方式" title="ES5中数组的遍历方式">ES5中数组的遍历方式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#es6中数组的遍历方式" title="ES6中数组的遍历方式">ES6中数组的遍历方式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#es6中数组方法" title="ES6中数组方法">ES6中数组方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#扩展运算符与rest参数" title="扩展运算符与rest参数">扩展运算符与rest参数</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#箭头函数" title="箭头函数">箭头函数</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#对象方法" title="对象方法">对象方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#类与继承" title="类与继承">类与继承</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#set-数据结构" title="Set 数据结构">Set 数据结构</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#weakset-数据结构" title="WeakSet 数据结构">WeakSet 数据结构</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#map-数据结构" title="Map 数据结构">Map 数据结构</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#weakmap-数据结构" title="WeakMap 数据结构">WeakMap 数据结构</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#数值扩展" title="数值扩展">数值扩展</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#reflect对象" title="Reflect对象">Reflect对象</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#iterator-迭代器" title="Iterator 迭代器">Iterator 迭代器</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#module-模块化" title="Module 模块化">Module 模块化</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8></ul></div></footer></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.6d5b5a7a.js" defer></script><script src="/blog/assets/js/6.fe35a745.js" defer></script><script src="/blog/assets/js/3.1b59b54d.js" defer></script><script src="/blog/assets/js/16.dad7f127.js" defer></script>
  </body>
</html>

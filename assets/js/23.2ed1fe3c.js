(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{334:function(a,e,l){"use strict";l.r(e);var r=l(5),t=Object(r.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),e("p",[a._v("webpack是很多前端开发在工程化构建项目，第一个学会使用的脚手架，哪怕你用的是 vue-cli或者create-react-app，他们底层都是 webpack 在封装、在开发的一个构建工具。")]),a._v(" "),e("p",[a._v("但是webpack特别难学；第一，官网语焉不详的文档，学习成本高，上手难度大。第二，webpack更新到5，代码量进一步加大，大约有73548 行代码，这个量级下源码的阅读、分析、学习成本极高。我把webpack分为三个阶段，从入口开始逐步分析源码。")]),a._v(" "),e("h3",{attrs:{id:"初始化阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#初始化阶段"}},[a._v("#")]),a._v(" 初始化阶段")]),a._v(" "),e("p",[e("strong",[a._v("执行webapack初始化的是webpack-cli，在执行命令中使用webpack 都会以软链接的方式调用webpack-cli。")])]),a._v(" "),e("ol",[e("li",[a._v("检查本地webpack-cli是否存在，版本是否需要更新。")]),a._v(" "),e("li",[a._v("webapck-cli脚手架定义定义")]),a._v(" "),e("li",[a._v("读取用户配置（如：package.josn），校验配置合并配置输出配置文件。")]),a._v(" "),e("li",[a._v("定义compiler对象，遍历本地plugin，执行或者注册。执行 compiler 生命周期钩子函数。")]),a._v(" "),e("li",[a._v("初始化 webpack")]),a._v(" "),e("li",[a._v("webpack-cli实例化")])]),a._v(" "),e("h4",{attrs:{id:"重点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重点"}},[a._v("#")]),a._v(" 重点！！！")]),a._v(" "),e("p",[a._v("在初始化的时候，要注意这个文件里的"),e("strong",[a._v("node_modules/webpack/lib/WebpackOptionsApply.js 的 process()")]),a._v(" 方法，虽然这个函数有快700行代码，但是这个函数是后续 webpack 把 “.vue .d.ts .ejs .scss” 等一系列代码转换成 AST 的重要代码，因为在初始化期间 webpack 就要 先执行 plugin 和 loader 才能识别代码并转换成浏览器能识别的 js 或者 css 等文件。")]),a._v(" "),e("p",[a._v("在这里 webpack 定义了一系列状态或者一套流程，插件进入 必须按照这套逻辑执行，但是插件也可以定义自己的流程或者状态，在 webpack 的生命钩子函数中执行。")]),a._v(" "),e("h3",{attrs:{id:"构建阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构建阶段"}},[a._v("#")]),a._v(" 构建阶段")]),a._v(" "),e("ol",[e("li",[a._v("在进程空闲，并且没有执行过 compiler.run()开始执行run()函数")]),a._v(" "),e("li",[a._v("调用compiler.hook下的方法：清除缓存并释放内存、注册插件、收集编译记录，一旦运行错误会调用finalCallback(err)方法，记录错误。")]),a._v(" "),e("li",[a._v("调用 onCompiled，执行状态流转。")]),a._v(" "),e("li",[a._v("生成 params 对象。（该对象中有所有构建模块需要的的钩子和方法，能生成编译模块工程AST的代码）")]),a._v(" "),e("li",[a._v("调用 compiler.hooks.beforeCompile 生命钩子函数")]),a._v(" "),e("li",[a._v("注册compilation编译用的钩子函数（约200行）；生成异步队列：日后需要编译的在推送到队列去。（compilation单执行 js 文件举例：jsModulesPlugin -> LoaderPlugin）")]),a._v(" "),e("li",[a._v("注册 EntryPlugin （入口），获取入口所有文件资源。")]),a._v(" "),e("li",[a._v("调用handleModuleCreate 生成 Module子类，调用 factorizeModule 生成模块化工厂。")]),a._v(" "),e("li",[a._v("创建loader、paser的执行状态")]),a._v(" "),e("li",[a._v("addModule，实例化Module对象")]),a._v(" "),e("li",[a._v("执行 build 方法，收集本地loader，执行runLoader")]),a._v(" "),e("li",[a._v("读取并转译源码，传入给paser， 执行paser.pase方法生成AST")]),a._v(" "),e("li",[a._v("AST 返回给 paser处理。")])]),a._v(" "),e("h3",{attrs:{id:"输出阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#输出阶段"}},[a._v("#")]),a._v(" 输出阶段")]),a._v(" "),e("h2",{attrs:{id:"写到最后"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#写到最后"}},[a._v("#")]),a._v(" 写到最后")]),a._v(" "),e("p",[a._v("其实webpack就是一个壳，跑的都是loader 和 plugin 执行流程或者是编译流程（包括我们在 规定入口 和出口的文件 都是用plugin来实现的），所以很多人叫webpack是一个状态机")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/6949040393165996040",title:"点击跳转",target:"_blank",rel:"noopener noreferrer"}},[a._v("参考文章"),e("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=t.exports}}]);
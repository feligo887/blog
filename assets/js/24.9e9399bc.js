(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{335:function(e,a,l){"use strict";l.r(a);var r=l(5),t=Object(r.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h3",{attrs:{id:"前置知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前置知识点"}},[e._v("#")]),e._v(" 前置知识点")]),e._v(" "),a("h4",{attrs:{id:"webpack-loader执行流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-loader执行流程"}},[e._v("#")]),e._v(" webpack-loader执行流程")]),e._v(" "),a("ul",[a("li",[e._v("loader是从下至上执行（像栈），所以在config.js要合理配置")]),e._v(" "),a("li",[e._v("每个loader上都有一个.pitch方法（可选），loader文件中，会先执行pitch。")]),e._v(" "),a("li",[e._v("pitch的作用：拦截Loader的执行、预处理。")]),e._v(" "),a("li",[e._v("pitch处理的数据只能在本文件生效，loader本身处理的可以透传。")]),e._v(" "),a("li",[e._v("所有的loader中的pitch执行完毕之后才会执行loader本身。")])]),e._v(" "),a("p",[a("strong",[e._v("官方事例：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("webpack.config.js\nmodule.exports = {\n  //...\n  module: {\n    rules: [\n      {\n        //...\n        use: [\n          'a-loader',\n          'b-loader',\n          'c-loader'\n        ]\n      }\n    ]\n  }\n};\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("console.log\n\n|- a-loader `pitch`\n  |- b-loader `pitch`\n    |- c-loader `pitch`\n      |- requested module is picked up as a dependency\n    |- c-loader normal execution\n  |- b-loader normal execution\n|- a-loader normal execution\n")])])]),a("h4",{attrs:{id:"vue-loader循环解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-loader循环解析"}},[e._v("#")]),e._v(" vue-loader循环解析")]),e._v(" "),a("ul",[a("li",[e._v(".vue模板中 template style script 等，被分割成块。")]),e._v(" "),a("li",[e._v("在读取 .vue 文件，这些块会被loader不断引入（import），不断的读取.vue文件，不断引入，直到全被引入完毕。")])]),e._v(" "),a("h4",{attrs:{id:"手动干预loader执行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手动干预loader执行"}},[e._v("#")]),e._v(" 手动干预loader执行")]),e._v(" "),a("ul",[a("li",[e._v("所有loader 都不执行")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" import ' - !${resourcePath}?vue&type=template&id=12345'; /n${content}'\n")])])]),a("ul",[a("li",[e._v("只执行某个loader")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("=import '- !${path. resolve(__dirname, 'Loader2.js')\n}!${resourcePath}?vue&type=template&id=12345\";\\n${content}\n")])])]),a("ul",[a("li")]),e._v(" "),a("h3",{attrs:{id:"vue-loader-plugin的做了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-loader-plugin的做了什么"}},[e._v("#")]),e._v(" vue-loader-plugin的做了什么")]),e._v(" "),a("ol",[a("li",[e._v("在vue-loader-plugin添加一个标记，判断vue-loader-plugin是否存在")]),e._v(" "),a("li",[e._v("收集webpack 引用的所有rules，拷贝并用webpack转化成 rulesSet 能被loader使用")]),e._v(" "),a("li",[e._v("动态添加其余的loader，例如：template-loader、pitcher-loader，并把loader添加到执行队列。")])]),e._v(" "),a("h3",{attrs:{id:"vue-loader的做了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-loader的做了什么"}},[e._v("#")]),e._v(" vue-loader的做了什么")]),e._v(" "),a("p",[a("strong",[e._v("三个块 （template、css、js）都是这样重复，执行顺序是 template -> js -> css")])]),e._v(" "),a("h4",{attrs:{id:"第一阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第一阶段"}},[e._v("#")]),e._v(" 第一阶段")]),e._v(" "),a("ol",[a("li",[e._v("在vue-loader-plugin添加一个标记，判断vue-loader-plugin是否存在")]),e._v(" "),a("li",[e._v("解析代码：获取文件路径、AST抽象代码树，拆分代码块（html，css，js等）生成一个 has值。")]),e._v(" "),a("li",[e._v("判断是代码所在环境，是否js语法糖，template渲染方式、css模块化等，生成新的块名：{名称}{type}{has}，")]),e._v(" "),a("li",[e._v("根据块的新名称，生成新的引用路径，并动态引用该模块（此时的模块不是真实的代码）。")]),e._v(" "),a("li",[e._v("增加热更新的源码，方便修改代码时快速引用。")])]),e._v(" "),a("h4",{attrs:{id:"第二阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第二阶段"}},[e._v("#")]),e._v(" 第二阶段")]),e._v(" "),a("ol",[a("li",[e._v("通过pitcher的resourceQuery方法，过滤掉非vue block")]),e._v(" "),a("li",[e._v("去除vue-loader不能使用的 ESlint-loader，调用合适的loader（template-loader、css-loader、js-loader等）解析，")]),e._v(" "),a("li",[e._v("生成一个带有loader地址的新引用路径，return 新路径并结束 后续所有loader的执行。")])]),e._v(" "),a("h4",{attrs:{id:"第三阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第三阶段"}},[e._v("#")]),e._v(" 第三阶段")]),e._v(" "),a("ol",[a("li",[e._v("进入pitcher 生成新的模块源码，再次执行 vue-loader。")]),e._v(" "),a("li",[e._v("判断不同的模块，执行对应的 loader（template-loader、css-loader、js-loader等）")]),e._v(" "),a("li",[e._v("template 生成 render 函数， js 生成 带有 script 标签的块， css 生成带有 style 标签的块")])]),e._v(" "),a("h3",{attrs:{id:"简单总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简单总结"}},[e._v("#")]),e._v(" 简单总结")]),e._v(" "),a("ol",[a("li",[e._v("利用webpack机制，初始化阶段执行plugin，会直接执行vue-loader-plugin。")]),e._v(" "),a("li",[e._v("vue-loader-plugin 在 loader 执行之前在 complier.hooks.compilation.tap 的钩子里面 定义了 vue-loader 的一个key，其作用是在执行loader 检查 vue-loader 是否执行")]),e._v(" "),a("li",[e._v("vue-loader-plugin 添加 解析.vue文件需要的loader，保证 vue-loader 能正常编译")]),e._v(" "),a("li",[e._v("webpack-loader的pitcher 拦截文件转为 js，不断调用 自身 寻找loader 编译代码生成带有loader标识的新路径。")]),e._v(" "),a("li",[e._v("获取路径中源码内容，调用loader编程，成为最终的 render 函数 或者 code")])])])}),[],!1,null,null,null);a.default=t.exports}}]);
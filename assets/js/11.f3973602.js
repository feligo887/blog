(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{300:function(e,n,t){e.exports=t.p+"assets/img/2022-12-31-balbel源码解析.23e11177.png"},333:function(e,n,t){"use strict";t.r(n);var a=t(5),r=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),n("p",[e._v("babel，是我们前端工程化开发中，必须使用的一个工具链，主要用于在当前和旧的浏览器或环境中，将 ECMAScript 2015+ 代码转换为 JavaScript 向后兼容版本的代码。")]),e._v(" "),n("p",[e._v("但是在我的理解中balbel就是一个代码转换机。让我们写的代码都能被浏览器识别并执行。在阅读balbel官方"),n("a",{attrs:{href:"https://github.com/jamiebuilds/the-super-tiny-compiler",title:"点击跳转",target:"_blank",rel:"noopener noreferrer"}},[e._v("the-super-tiny-compiler "),n("OutboundLink")],1),e._v("给出的代码后，\n大多数代码都会经历以下步骤：")]),e._v(" "),n("ul",[n("li",[e._v("解析（parse）")]),e._v(" "),n("li",[e._v("转换（transform）")]),e._v(" "),n("li",[e._v("生成（generate）")])]),e._v(" "),n("p",[e._v("我们将执行下列代码作为事例演示：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("fn(1 2);\n")])])]),n("h2",{attrs:{id:"解析-parse"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解析-parse"}},[e._v("#")]),e._v(" 解析（parse）")]),e._v(" "),n("p",[e._v("解析步骤接收代码并输出 AST。 这个步骤分为两个阶段：")]),e._v(" "),n("ul",[n("li",[e._v("词法分析（tokenizer）")]),e._v(" "),n("li",[e._v("语法分析（parser）")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("//  词法分析阶段把字符串形式的代码转换为 令牌（tokens） 流。\nconst tokens = [\n  { type: 'name',   value: 'fn' },\n  { type: 'paren',  value: '('  },\n  { type: 'number', value: '1'  },\n  { type: 'number', value: '2'  },\n  { type: 'paren',  value: ')'  }\n];\n\n// 语法分析阶段会把一个令牌流转换成 AST 的形式。 这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。\n\nconst ast = {\n  type: 'Program',\n  body: [{\n    type: 'CallExpression',\n    name: 'fn',\n    params: [{\n      type: 'NumberLiteral',\n      value: '1'\n    },{\n      type: 'NumberLiteral',\n      value: '2'\n    }]\n  }]\n};\n\n")])])]),n("h2",{attrs:{id:"转换-transform"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#转换-transform"}},[e._v("#")]),e._v(" 转换（transform）")]),e._v(" "),n("p",[e._v("这里的代码是最复杂的，但是逻辑很简单。大致分为以下几个步骤：")]),e._v(" "),n("ol",[n("li",[e._v("声明一个newAst作为容器接受转换后的数据。")]),e._v(" "),n("li",[e._v("调用traverser函数，传入AST和一个obj对象")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    traverser(ast, {\n        NumberLiteral: {\n            enter(node, parent) {\n                parent._context.push({\n                    type: 'NumberLiteral',\n                    value: node.value,\n                });\n            },\n        },\n\n        StringLiteral: {\n            enter(node, parent) {\n                parent._context.push({\n                    type: 'StringLiteral',\n                    value: node.value,\n                });\n            },\n        },\n\n        CallExpression: {\n            enter(node, parent) {\n                let expression = {\n                    type: 'CallExpression',\n                    callee: {\n                        type: 'Identifier',\n                        name: node.name,\n                    },\n                    arguments: [],\n                };\n\n                node._context = expression.arguments;\n\n                if (parent.type !== 'CallExpression') {\n\n                    expression = {\n                        type: 'ExpressionStatement',\n                        expression: expression,\n                    };\n                }\n\n                parent._context.push(expression);\n            },\n        }\n    });\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[e._v("执行traverser；traverser内部是多个函数，不断递归调用 AST（因为AST是多位数组），在此过程中对节点进行添加、更新及移除等操作。")]),e._v(" "),n("li",[e._v("返回newAST。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。 这是 Babel 或是其他编译器中最复杂的过程 同时也是插件将要介入工作的部分\n\nconst newAst = {\n  type: 'Program',\n  body: [{\n    type: 'ExpressionStatement',\n    expression: {\n      type: 'CallExpression',\n      callee: {\n        type: 'Identifier',\n        name: 'fn'\n      },\n      arguments: [{\n        type: 'NumberLiteral',\n        value: '1'\n      },{\n        type: 'NumberLiteral',\n        value: '2'\n      }]\n    }\n  }]\n};\n")])])]),n("h2",{attrs:{id:"生成-generate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#生成-generate"}},[e._v("#")]),e._v(" 生成（generate）")]),e._v(" "),n("p",[e._v("代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps）。")]),e._v(" "),n("p",[e._v("代码生成其实很简单：深度优先遍历整个 AST，然后根据 type类型 判断、处理 拼接可以表示转换后代码的字符串。")]),e._v(" "),n("p",[e._v("下面的主要功能代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function codeGenerator(node) {\n\n    switch (node.type) {\n\n        case 'Program':\n            return node.body.map(codeGenerator)\n                .join('\\n');\n\n        case 'ExpressionStatement':\n            return (\n                codeGenerator(node.expression) +\n                ';'\n            );\n\n        case 'CallExpression':\n            return (\n                codeGenerator(node.callee) +\n                '(' +\n                node.arguments.map(codeGenerator)\n                    .join(', ') +\n                ')'\n            );\n\n        case 'Identifier':\n            return node.name;\n\n        case 'NumberLiteral':\n            return node.value;\n\n        case 'StringLiteral':\n            return '\"' + node.value + '\"';\n\n        default:\n            throw new TypeError(node.type);\n    }\n}\n")])])]),n("p",[e._v("执行完上述代码后返回 fn(1, 2) 浏览器能正常执行的代码了")]),e._v(" "),n("h3",{attrs:{id:"代码流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#代码流程"}},[e._v("#")]),e._v(" 代码流程")]),e._v(" "),n("img",{attrs:{src:t(300)}})])}),[],!1,null,null,null);n.default=r.exports}}]);
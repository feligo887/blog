(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{328:function(a,n,t){"use strict";t.r(n);var e=t(5),l=Object(e.a)({},(function(){var a=this,n=a._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("p",[a._v("请说出下列代码回答一下问题")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var a = {n: 1};\nvar b = a;\na.x = a = {n: 2};\n//  a.x的值是什么\n//  b.x的值是什么\n")])])]),n("p",[a._v("其实这个问题主要是考验下面两个知识点：")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("JS引擎对赋值表达式的处理过程")])]),a._v(" "),n("li",[n("p",[a._v("赋值运算的右结合性")])])]),a._v(" "),n("p",[a._v("这里可以分成如下几步去理解")]),a._v(" "),n("ul",[n("li",[a._v("var a = {n: 1};\n声明一个变量a，并为其赋值一个对象")]),a._v(" "),n("li",[a._v("var b = a;\n创建一个变量b，为其赋值对象a。在栈内存中，a与b是不同的，是两个变量，但是他们的指针是相同的，指向同一个堆")]),a._v(" "),n("li",[a._v("a.x = a = {n: 2};")]),a._v(" "),n("li",[n("ol",[n("li",[a._v("先获取等号左侧的a.x，但a.x并不存在。于是JS为（堆内存中的）对象创建一个新成员x，这个成员的初始值为undefined。（这也是为什么直接引用一个未定义的变量会报错，但是直接引用一个对象的不存在的成员时，会返回undefined）")])])]),a._v(" "),n("li",[n("ol",{attrs:{start:"2"}},[n("li",[a._v("创建完成后，目标指针已经指向了这个新成员x，并会先挂起。等号右侧的内容有结果了，完成赋值。")])])]),a._v(" "),n("li",[n("ol",{attrs:{start:"3"}},[n("li",[a._v("执行赋值语句的右侧，发现a={n:2}是个简单的赋值操作，于是a的新值等于了{n:2}。（注意，这个a已经不是开头的那个a，而是new a。new a指针已经不是指向 a的堆内存，而是分配了一个新的堆内存。但是原来旧的堆内存因为还有b在占用，所以并未被回收。")])])]),a._v(" "),n("li",[n("ol",{attrs:{start:"4"}},[n("li",[a._v("new a的堆内存指针，赋值给了刚才挂起的新成员x,此时，对象成员x便等于了new a。")])])]),a._v(" "),n("li",[n("ol",{attrs:{start:"5"}},[n("li",[a._v("所以，b={n:1,x:{n:2};a={n:2};a===b.x(true,注意对象的相等，不是值的相等，而是引用的相等，也就是说，相等表示指针是指向同一个堆内存。)")])])])]),a._v(" "),n("h4",{attrs:{id:"结果-a-x-undefined-b-x-n-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#结果-a-x-undefined-b-x-n-2"}},[a._v("#")]),a._v(" 结果: a.x === undefined，b.x === {n:2}")]),a._v(" "),n("p",[a._v("资料参考：")]),a._v(" "),n("blockquote",[n("p",[a._v("知乎作者：无为\n知乎链接：https://www.zhihu.com/question/41220520/answer/151955851")])])])}),[],!1,null,null,null);n.default=l.exports}}]);